<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="MSG_ArgGreaterEqual" xml:space="preserve">
    <value>{0} の値 {1} が {2} の値 {3} より小さいです。{0} の値は {2} の値より大きいか、等しくなければなりません。</value>
  </data>
  <data name="MSG_ArgRangeError" xml:space="preserve">
    <value>{0} として指定の値 {1} は、{2} ~ {3} の範囲外です。範囲内の値を指定してください。</value>
  </data>
  <data name="MSG_CanNotBeIndexRegister" xml:space="preserve">
    <value>指定のレジスタ {0} は指標レジスタとして使えません。指標レジスタとして用いる GR は、記号 GR{1}～GR{2} で指定してください。</value>
  </data>
  <data name="MSG_CanNotRepresentInJisx0201" xml:space="preserve">
    <value>文字 '{0}' は JIS X 0201 で表せません。JIS X 0201 で表せる文字を使ってください。</value>
  </data>
  <data name="MSG_ConstantParseError" xml:space="preserve">
    <value>{0} を定数として解釈できませんでした。10 進定数 (n)、16 進定数 (#h)、文字定数 ('文字列')、アドレス定数 (ラベル) のいずれかを記述してください。</value>
  </data>
  <data name="MSG_CouldNotAddToWordCollection" xml:space="preserve">
    <value>語のコレクションに語を追加できませんでした。語のコレクションの最大サイズ {0} を超える語を追加しようとしています。</value>
  </data>
  <data name="MSG_CouldNotMakeLiteralLabel" xml:space="preserve">
    <value>リテラルで使用する DC 命令のラベルを作成できませんでした。"{0}" で始まる名前のラベルを減らしてください。</value>
  </data>
  <data name="MSG_CouldNotParseAsAdr" xml:space="preserve">
    <value>字句要素 {0} をアドレスとして解釈できませんでした。アドレスは、10 進定数、16 進定数、アドレス定数又はリテラルで指定してください。</value>
  </data>
  <data name="MSG_CouldNotParseAsToken" xml:space="preserve">
    <value>文字 '{0}' で始まる句ををオペランドの字句要素として解釈できませんでした。オペランドの字句要素には、10 進定数 (n)、16 進定数 (#h)、文字定数 ('文字列')、アドレス定数 (ラベル)、レジスタ名 (GRn)、リテラル (=定数) があります。</value>
  </data>
  <data name="MSG_CpuExecutionError" xml:space="preserve">
    <value>アドレス #{0:x04} の命令 #{1:x04} の実行でエラーが発生しました。詳細は InnerException を参照してください。</value>
  </data>
  <data name="MSG_FailedToParseR2OrAdrX" xml:space="preserve">
    <value>オペランド "r1,r2" 又は "r,adr[,x]" で、r2 あるいは adr を解釈できませんでした。レジスタ名かアドレスを指定してください。詳細は InnerException を参照してください。</value>
  </data>
  <data name="MSG_InstructionAfterEnd" xml:space="preserve">
    <value>END 命令の後に命令が書かれています。END 命令の後には命令を書かないでください。</value>
  </data>
  <data name="MSG_InstructionNotDefined" xml:space="preserve">
    <value>指定の命令コード "{0}" は定義されていません。</value>
  </data>
  <data name="MSG_InvalidCharForDecimalConstant" xml:space="preserve">
    <value>指定の文字 '{0}' は 10 進定数を記述する半角数字 (0~9) ではありません。10 進定数には半角数字を使用してください。</value>
  </data>
  <data name="MSG_InvalidHexConstantDigitCount" xml:space="preserve">
    <value>16 進定数として指定の文字列 "{0}" の桁数が {1} 桁ではなく {2} 桁です。16 進定数は #h の形式で、h は {1} 桁の 16 進数 (0~9, A~F) で指定します。</value>
  </data>
  <data name="MSG_LabelAlreadyDefined" xml:space="preserve">
    <value>ラベル "{0}" はすでに定義されています。ラベルの名前はプログラムの中で一意にしてください。</value>
  </data>
  <data name="MSG_LabelFirstCharIsNotUppercase" xml:space="preserve">
    <value>ラベル "{0}" の先頭の文字 '{1}' が半角英大文字ではありません。ラベルの先頭の文字は半角英大文字にしてください。</value>
  </data>
  <data name="MSG_LabelIsReservedWord" xml:space="preserve">
    <value>ラベル "{0}" は予約語です。ラベルには予約語を使わないでください。予約語は {1} です。 </value>
  </data>
  <data name="MSG_LabelLengthOutOfRange" xml:space="preserve">
    <value>ラベル "{0}" の長さ {1} 文字は有効な範囲外です。ラベルの長さは {2} ~ {3} 文字にしてください。</value>
  </data>
  <data name="MSG_LabelNotDefined" xml:space="preserve">
    <value>定義されていないラベル "{0}" を参照しています。指定のラベルを定義してください。</value>
  </data>
  <data name="MSG_LabelSubsequentCharIsNeitherUppercaseNorDigit" xml:space="preserve">
    <value>ラベル "{0}" の文字 '{1}' が、半角英大文字でも半角数字でもありません。ラベルの 2 文字目以降は、半角英大文字または半角数字にしてください。</value>
  </data>
  <data name="MSG_LiteralParseError" xml:space="preserve">
    <value>{0} をリテラルとして解釈できませんでした。リテラルは、10 進定数、16 進定数、または文字定数の前に等号 (=) を付けて記述します。</value>
  </data>
  <data name="MSG_MemoryAddressOutOfRange" xml:space="preserve">
    <value>メモリアドレスの値 {0} (= {1} ({2}) + {3} ({4}) が COMET II 主記憶のアドレス範囲 {5} ~ {6} に入りません。プログラムを小さくするなど、主記憶に入るようにしてください。</value>
  </data>
  <data name="MSG_MoreThanOneEndInstruction" xml:space="preserve">
    <value>プログラムに 2 つ以上の END 命令があります。END 命令は 1 つだけ指定してください。</value>
  </data>
  <data name="MSG_MoreThanOneStartInstruction" xml:space="preserve">
    <value>プログラムに 2 つ以上の START 命令があります。START 命令は 1 つだけ指定してください。</value>
  </data>
  <data name="MSG_NoCloseQuoteInStrConstant" xml:space="preserve">
    <value>指定の文字定数 "{0}" で、閉じ側のアポストロフィ (') がありません。</value>
  </data>
  <data name="MSG_NoEndInstruction" xml:space="preserve">
    <value>プログラムに END 命令がありません。プログラムには END 命令を 1 つ指定し、プログラムの終わりを定義してください。</value>
  </data>
  <data name="MSG_NoInstructionInInstructionLine" xml:space="preserve">
    <value>命令コードがありません。命令行には、オプションのラベルと空白に続いて、命令コードがなければなりません。</value>
  </data>
  <data name="MSG_NoLabel" xml:space="preserve">
    <value>ラベルを予期していましたが指定されていませんでした。ラベルを指定してください。</value>
  </data>
  <data name="MSG_NoLabelForStart" xml:space="preserve">
    <value>START 命令にラベルがありません。START 命令のラベルは、他のプログラムから入口名として参照します。ラベルを指定してください。</value>
  </data>
  <data name="MSG_NoStartInstruction" xml:space="preserve">
    <value>プログラムに START 命令がありません。プログラムには START 命令を 1 つ指定し、プログラムの先頭を定義してください。</value>
  </data>
  <data name="MSG_NotExpectedChar" xml:space="preserve">
    <value>次の文字として '{0}' を予期していましたが、実際の文字は '{1}' でした。</value>
  </data>
  <data name="MSG_NotExpectedToken" xml:space="preserve">
    <value>オペランドの字句要素として {0} を予期していましたが、実際は {1} でした。{0} を記述してください。</value>
  </data>
  <data name="MSG_NotParsedStringRemainsInOperand" xml:space="preserve">
    <value>{0} 命令のオペランド "{1}" で "{2}" が解釈できずに残りました。記述形式を確認してください。</value>
  </data>
  <data name="MSG_OperandNeitherRAdrXNorR1R2" xml:space="preserve">
    <value>オペランドを r,adr[,x] としても r1,r2 としても解釈できませんでした。オペランドに r,adr[,x] あるいは r1,r2 を指定してください。</value>
  </data>
  <data name="MSG_OperandParseError" xml:space="preserve">
    <value>{0} 命令のオペランドの解釈で問題が発生しました。オペランドの記述形式は {1} です。確認してください。</value>
  </data>
  <data name="MSG_OptionLabelParseError" xml:space="preserve">
    <value>{0} をラベルとして解釈できませんでした。オペランドは、空にするか、ラベルを指定してください。</value>
  </data>
  <data name="MSG_RegisteringOffsetForNotDefinedLabel" xml:space="preserve">
    <value>定義されていないラベル "{0}" のオフセットを登録しようとしています。プログラムになにか問題があります。</value>
  </data>
  <data name="MSG_StartLabelNotDefined" xml:space="preserve">
    <value>START 命令のオペランドに指定した実行開始番地のラベル "{0}" が定義されていません。ラベルを定義してください。</value>
  </data>
  <data name="MSG_UndefinedOpcode" xml:space="preserve">
    <value>命令コード 0x{0:x02} は未定義です。</value>
  </data>
  <data name="MSG_UndefinedRegisterName" xml:space="preserve">
    <value>指定の文字列 "{0}" はレジスタ名ではありません。レジスタ名は、記号 {1}~{2} で指定してください。</value>
  </data>
  <data name="MSG_WordCountOutOfRange" xml:space="preserve">
    <value>語数に指定の値 {0} は有効範囲外です。有効範囲 {1} &lt;= 語数 &lt;= {2} の値を指定してください。</value>
  </data>
  <data name="MSG_ZeroCharsInStringConstant" xml:space="preserve">
    <value>文字列定数の文字数が 0 です。文字列定数には 1 文字以上の文字を指定してください。</value>
  </data>
  <data name="STR_DecimalConstant" xml:space="preserve">
    <value>10 進定数</value>
  </data>
  <data name="STR_EndOfStr" xml:space="preserve">
    <value>文字列の終わり</value>
  </data>
  <data name="STR_EndOfToken" xml:space="preserve">
    <value>オペランドの終わり</value>
  </data>
  <data name="STR_HexaDecimalConstant" xml:space="preserve">
    <value>16 進定数</value>
  </data>
  <data name="STR_IndexerArgDscr" xml:space="preserve">
    <value>{0} のインデクサーの引数 {1}</value>
  </data>
  <data name="STR_Label" xml:space="preserve">
    <value>ラベル</value>
  </data>
  <data name="STR_RegisterName" xml:space="preserve">
    <value>レジスタ名</value>
  </data>
  <data name="STR_StringConstant" xml:space="preserve">
    <value>文字定数</value>
  </data>
  <data name="SYN_AdrX" xml:space="preserve">
    <value>adr[,x]</value>
  </data>
  <data name="SYN_ConstantList" xml:space="preserve">
    <value>"定数[,定数]..."</value>
  </data>
  <data name="SYN_ExecStartAddr" xml:space="preserve">
    <value>"[実行開始番地]"</value>
  </data>
  <data name="SYN_InputArea" xml:space="preserve">
    <value>"入力領域,入力文字長領域"</value>
  </data>
  <data name="SYN_NoOperand" xml:space="preserve">
    <value>オペランドなし</value>
  </data>
  <data name="SYN_OutputArea" xml:space="preserve">
    <value>"出力領域,出力文字長領域"</value>
  </data>
  <data name="SYN_R" xml:space="preserve">
    <value>r</value>
  </data>
  <data name="SYN_R1R2" xml:space="preserve">
    <value>r1,r2</value>
  </data>
  <data name="SYN_RAdrX" xml:space="preserve">
    <value>r,adr[,x]</value>
  </data>
  <data name="SYN_RAdrXOrR1R2" xml:space="preserve">
    <value>r,adr[,x] あるいは r1,r2</value>
  </data>
  <data name="SYN_WordCount" xml:space="preserve">
    <value>語数</value>
  </data>
</root>